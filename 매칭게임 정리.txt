------------------------------------------------------- 4x4 판짜기

case WM_PAINT:
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    // 4x4 판 그리기
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            // 각 칸의 위치 계산
            int x = j * TILE_SIZE;
            int y = i * TILE_SIZE;

            // 각 칸을 사각형으로 그리기
            Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);
        }
    }

    EndPaint(hWnd, &ps);
}
break;


-> 설명 : 

1. ------------------
for (int j = 0; j < BOARD_SIZE; j++)
두 번째 중첩된 반복문은 각 열을 처리합니다. 이 반복문도 BOARD_SIZE만큼 반복되며, 각 행에서 열을 차례대로 처리합니다.

2.-------------------
int x = j * TILE_SIZE;
x는 각 칸의 왼쪽 상단 모서리의 X 좌표입니다. TILE_SIZE는 한 칸의 크기이므로, j에 TILE_SIZE를 곱하면 각 칸의 위치가 계산됩니다.

3.-------------------
int y = i * TILE_SIZE;
y는 각 칸의 왼쪽 상단 모서리의 Y 좌표입니다. i에 TILE_SIZE를 곱하여 세로 위치를 계산합니다.

4.-------------------

Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);
Rectangle 함수는 지정된 좌표에 사각형을 그립니다. hdc는 그리기 장치 컨텍스트, (x, y)는 사각형의 왼쪽 상단 모서리 좌표, (x + TILE_SIZE, y + TILE_SIZE)는 사각형의 오른쪽 하단 모서리 좌표입니다. 이 코드에서는 x와 y가 각 칸의 왼쪽 상단 좌표가 되고, x + TILE_SIZE와 y + TILE_SIZE는 각 칸의 크기에 맞게 오른쪽 하단 좌표가 됩니다. 즉, 이 코드로 TILE_SIZE 크기의 사각형을 그립니다.

결론 -> 사각형이 오른쪽으로 그려지고 4개를 그리면 i가 1 추가되어 y좌표가 128픽셀 이동 아래서부터 다시 오른쪽으로 사각형 그림 
4x4판을 만든다.

---------------------------------------------------------------------- 이미지 추가


#define BOARD_SIZE 4 //보드의 크기 (4x4)
#define TILE_SIZE 128  // 각 칸의 크기 (128x128 픽셀)


HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        // 과일 이미지 8개를 로드
        FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
        FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
        FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
        FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
        FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
        FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
        FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
        FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * TILE_SIZE; //시작 x좌표 0
                int y = i * TILE_SIZE; //시작 y좌표 0

                // 각 칸을 사각형으로 그리기
                Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);

                // 이미지를 각 칸에 그리기
                int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                // 비트맵을 각 칸에 맞게 복사
                BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);

            }
        }

        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;

--> 설명

--> 리소스 파일을 사용하려면 resource.h 파일을 포함해야 합니다. 


1.------------------------

HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열
FruitImages 배열은 8개의 HBITMAP 객체를 저장할 수 있는 배열입니다. 각 HBITMAP 객체는 비트맵 이미지를 나타냅니다. 
이 배열에 8개의 과일 이미지를 로드하여 저장할 것입니다.

2.-----------------------

CreateCompatibleDC(hdc)는 hdc와 호환되는 메모리 DC를 생성합니다. 메모리 DC는 화면에 직접 그리지 않고, 
메모리 내에서 그래픽 작업을 할 수 있게 해줍니다. 이를 통해 비트맵 이미지를 로드하고, 그 이미지를 화면에 복사할 수 있습니다.

CreateCompatibleDC는 화면에 그림을 직접 그리지 않고, 메모리 버퍼 내에서 그래픽을 먼저 그린 후, 화면에 출력하는 작업을 할 때 주로 사용됩니다. 이를 통해 비트맵 처리나 이미지 복사 등의 작업을 효율적으로 수행할 수 있습니다.

3.-----------------------
메모리 DC의 사용 과정:
메모리 DC 생성: CreateCompatibleDC를 사용하여 화면과 호환되는 메모리 DC를 생성합니다.

비트맵 선택: SelectObject를 사용하여 메모리 DC에 비트맵을 선택합니다.

그래픽 작업: 메모리 DC 내에서 그래픽 작업을 수행합니다 (예: 비트맵 그리기, 텍스트 출력 등).

화면으로 복사: BitBlt 또는 StretchBlt 함수를 사용하여 메모리 DC에서 화면 DC로 이미지를 복사합니다.

자원 해제: 작업이 끝나면 DeleteDC를 사용하여 메모리 DC를 해제합니다.

4.----------------------------

LoadBitmap 함수는 리소스 ID를 사용하여 비트맵 이미지를 로드합니다. hInst는 현재 애플리케이션의 인스턴스 핸들입니다.
MAKEINTRESOURCE(IDB_BITMAP1)은 IDB_BITMAP1 리소스 식별자를 비트맵 리소스로 변환하여 LoadBitmap에 전달합니다.
총 8개의 과일 이미지가 FruitImages 배열에 로드됩니다.


6.-----------------------------

imageIndex는 현재 그리드 칸에 해당하는 이미지를 선택합니다. 8개의 이미지를 순환하기 위해 (i * BOARD_SIZE + j) % 8로 인덱스를 계산합니다.
SelectObject는 메모리 DC에 선택한 이미지를 할당합니다. 이제 이 DC에 선택된 이미지를 그릴 수 있게 됩니다.


7.-------------------------

BitBlt 함수는 메모리 DC에 있는 이미지를 실제 화면의 지정된 위치에 복사합니다. x, y는 그리드 칸의 좌표이고, TILE_SIZE는 그리드 칸의 크기입니다.
SRCCOPY는 소스 이미지를 그대로 복사하겠다는 의미입니다.

8.------------------------

작업이 끝난 후, DeleteDC 함수로 메모리 DC를 해제합니다. 메모리 DC는 화면에 그림을 그리지 않고 메모리 내에서 작업을 처리하는 DC이므로, 사용 후에는 반드시 해제해야 합니다.


-------------------------------3. 선 추가하기 구분위해

 // 4x4 판 그리기
for (int i = 0; i < BOARD_SIZE; i++) {
    for (int j = 0; j < BOARD_SIZE; j++) {
        // 각 칸의 위치 계산
        int x = j * TILE_SIZE; //시작 x좌표 0
        int y = i * TILE_SIZE; //시작 y좌표 0

        // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
        // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
        HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
        HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

        // 각 칸을 사각형으로 그리기 (구분선 추가)
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x + TILE_SIZE, y);
        LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
        LineTo(hdc, x, y + TILE_SIZE);
        LineTo(hdc, x, y);

        // 펜 복원
        SelectObject(hdc, hOldPen);
        DeleteObject(hPen); // 사용한 펜 삭제



MoveToEx: 이 함수는 그리기 시작 지점을 설정합니다. x와 y는 각 타일의 좌상단 좌표로, 이 지점부터 선을 그리기 시작합니다.
LineTo: 이 함수는 현재 위치에서 지정된 좌표로 선을 그립니다. 5개의 LineTo 함수 호출을 통해 사각형을 그리게 됩니다.
첫 번째 LineTo(hdc, x + TILE_SIZE, y)는 오른쪽 상단으로 선을 그립니다.
두 번째 LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE)는 오른쪽 하단으로 선을 그립니다.
세 번째 LineTo(hdc, x, y + TILE_SIZE)는 왼쪽 하단으로 선을 그립니다.
네 번째 LineTo(hdc, x, y)는 시작 지점으로 돌아오며 사각형을 닫습니다.
이렇게 하면 각 칸마다 굵은 검은색 선으로 구분된 사각형 경계선이 그려집니다.



---------------------------------------------- 여기까지 기본적인 게임판 그리기 (이미지 부분)

-->게임 로직 구현
----------------------------------------------4. 이미지 2개 뒤집기


#define BOARD_SIZE 4 //보드의 크기 (4x4)
#define TILE_SIZE 128  // 각 칸의 크기 (128x128 픽셀)


HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열

int clickedX[2] = { 0,0 };
int clickedY[2] = { 0,0 };  // 클릭된 좌표 저장 (최대 2개)
int clickCount = 0;  // 클릭 횟수 추적



LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        // 과일 이미지 8개를 로드
        FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
        FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
        FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
        FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
        FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
        FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
        FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
        FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * TILE_SIZE; //시작 x좌표 0
                int y = i * TILE_SIZE; //시작 y좌표 0

                // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
                // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
                HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

                // 각 칸을 사각형으로 그리기 (구분선 추가)
                MoveToEx(hdc, x, y, NULL);
                LineTo(hdc, x + TILE_SIZE, y);
                LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
                LineTo(hdc, x, y + TILE_SIZE);
                LineTo(hdc, x, y);

                // 펜 복원
                SelectObject(hdc, hOldPen);
                DeleteObject(hPen); // 사용한 펜 삭제

                // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
                for (int index = 0; index < clickCount; index++) {
                    if (clickedX[index] == j && clickedY[index] == i) {
                        int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                        HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                        SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                        // 비트맵을 각 칸에 맞게 복사
                        BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
                    }
                }

            }
        }

        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;
    case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
    {
        // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);

        // 클릭된 칸의 인덱스를 계산
        int px = x / TILE_SIZE; // 클릭된 칸의 x 좌표 (0부터 시작)
        int py = y / TILE_SIZE; // 클릭된 칸의 y 좌표 (0부터 시작)

        // 이미 클릭된 칸인지 확인
        if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
            // 이미 클릭된 칸이라면 처리하지 않고 리턴
            return 0;
        }

        // 클릭 횟수에 따라 처리
        if (clickCount < 2) {
            clickedX[clickCount] = px;
            clickedY[clickCount] = py;
            clickCount++;
        }
        else {
            // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
            clickedX[0] = px;
            clickedY[0] = py;
            clickedX[1] = -1;  // 두 번째 이미지는 사라짐
            clickedY[1] = -1;
            clickCount = 1; // 다시 첫 번째 클릭 상태로
        }

        InvalidateRect(hWnd, NULL, TRUE); // 화면 다시 그리기
    }
    break;

-->설명


1.-------------------------

clickedX[2], clickedY[2]: 클릭된 좌표를 저장하는 배열입니다. 최대 2개까지 좌표를 저장할 수 있습니다.
clickCount: 클릭된 횟수를 추적합니다. 2번 클릭 후 다시 1번 클릭 상태로 돌아갑니다.


2.----------------

// 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
for (int index = 0; index < clickCount; index++) {
    if (clickedX[index] == j && clickedY[index] == i) {
        int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
        HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
        SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

        // 비트맵을 각 칸에 맞게 복사
        BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
    }
}


--> 클릭된 좌표에 해당하는 칸을 확인하고, 그 칸에 해당하는 이미지를 BitBlt를 사용하여 그립니다. 이미지는 8개로 순차적으로 반복됩니다.


3.-------------

case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
{
    // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
    int x = LOWORD(lParam);
    int y = HIWORD(lParam);

    // 클릭된 칸의 인덱스를 계산
    int newX = x / TILE_SIZE; // 클릭된 칸의 x 좌표
    int newY = y / TILE_SIZE; // 클릭된 칸의 y 좌표

--> 마우스 클릭 시, 화면의 좌표를 LOWORD와 HIWORD로 추출하여 해당하는 보드 칸의 x, y 좌표를 계산합니다.

4.-----------------------

// 클릭 횟수에 따라 처리
if (clickCount < 2) {
    clickedX[clickCount] = newX;
    clickedY[clickCount] = newY;
    clickCount++;
}
else {
    // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
    clickedX[0] = newX;
    clickedY[0] = newY;
    clickedX[1] = -1;  // 두 번째 이미지는 사라짐
    clickedY[1] = -1;
    clickCount = 1; // 다시 첫 번째 클릭 상태로
}


--> 클릭 횟수가 2보다 작은 경우, 클릭된 좌표를 배열에 저장하고 clickCount를 증가시킵니다.
클릭 횟수가 2 이상이면 첫 번째 클릭으로 돌아가서 두 번째 이미지를 사라지게 합니다.

5.---------------

InvalidateRect를 호출하여 창을 다시 그려 클릭된 이미지를 반영합니다.

6.----------------

(clickedX[0] == newX && clickedY[0] == newY) || (clickedX[1] == newX && clickedY[1] == newY) 조건문을 추가하여, 이미 클릭된 칸이면 그 클릭을 무시하고 아무 동작도 하지 않도록 처리합니다.


---- > 이미지가 안보이게 설정 어케안건지 알아두기

---------------------------------------------------------------------5. 이미지 랜덤 위치 변경

int imageIndices[BOARD_SIZE * BOARD_SIZE];  // 이미지 인덱스를 저장할 배열
bool imagesLoaded = false;  // 이미지를 한 번만 로드하도록 하기 위한 플래그



LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        if (!imagesLoaded) {
            // 과일 이미지 8개를 로드
            FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
            FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
            FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
            FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
            FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
            FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
            FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
            FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


            // 이미지 인덱스를 초기화
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                imageIndices[i] = i % 8;  // 8개의 이미지로 순환
            }

            // 랜덤으로 이미지 인덱스 섞기
            srand((unsigned int)time(NULL));  // 랜덤 시드 설정
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                int randomIndex = rand() % (BOARD_SIZE * BOARD_SIZE); // 랜덤 인덱스
                // 이미지 인덱스를 서로 교환
                int temp = imageIndices[i];
                imageIndices[i] = imageIndices[randomIndex];
                imageIndices[randomIndex] = temp;
            }

            imagesLoaded = true;  // 이미지를 로드했으므로 플래그 설정
        }



         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * TILE_SIZE; //시작 x좌표 0
                int y = i * TILE_SIZE; //시작 y좌표 0

                // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
                // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
                HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

                // 각 칸을 사각형으로 그리기 (구분선 추가)
                MoveToEx(hdc, x, y, NULL);
                LineTo(hdc, x + TILE_SIZE, y);
                LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
                LineTo(hdc, x, y + TILE_SIZE);
                LineTo(hdc, x, y);

                // 펜 복원
                SelectObject(hdc, hOldPen);
                DeleteObject(hPen); // 사용한 펜 삭제

                // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
                for (int index = 0; index < clickCount; index++) {
                    if (clickedX[index] == j && clickedY[index] == i) {
                        //int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                        int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
                        HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                        SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                        // 비트맵을 각 칸에 맞게 복사
                        BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
                    }
                }

            }
        }

        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;



---> 설명


1.-------------------------------------

mageIndices[16]: 4x4 보드에서 각 칸에 할당된 이미지를 표시하기 위한 인덱스를 저장하는 배열입니다. 보드는 16칸(4x4)이므로 총 16개의 이미지 인덱스가 필요합니다.
imagesLoaded: 이미지를 한 번만 로드하도록 하는 플래그입니다.

2.--------------------------------------

imagesLoaded가 false일 경우, 8개의 과일 이미지를 LoadBitmap 함수를 사용하여 로드합니다.

3.-------------------------------

  // 이미지 인덱스를 초기화
    for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
        imageIndices[i] = i % 8;  // 8개의 이미지로 순환
    }
imageIndices 배열을 초기화하여, 각 칸에 8개의 이미지를 순환하여 배치합니다. 4x4 보드에서는 각 이미지를 2번씩 배치하는 구조입니다.


4.-------------------------

srand로 랜덤 시드를 설정하고, rand()로 랜덤하게 imageIndices 배열을 섞습니다. 이렇게 하면 보드에 나타나는 이미지들이 섞여서 표시됩니다.
imagesLoaded를 true로 설정하여 이미지 로드를 완료했음을 표시합니다.

5.------------------------
 // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
        for (int index = 0; index < clickCount; index++) {
            if (clickedX[index] == j && clickedY[index] == i) {
                // 랜덤으로 배치된 이미지 인덱스를 선택
                int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
                HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                // 비트맵을 각 칸에 맞게 복사
                BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
            }
        }
    }
}
사용자가 클릭한 칸에 이미지를 표시합니다. clickedX와 clickedY 배열에 저장된 좌표에 대해 이미지를 표시합니다.
imageIndices[i * BOARD_SIZE + j]를 사용해 해당 칸에 표시할 이미지를 결정하고, BitBlt로 이미지를 그립니다.


---------------------------- 오류 해결 첫번쨰 타일 클릭안됨

맞습니다! clickedX와 clickedY를 초기화할 때, 값이 0, 0이 아닌 -1, -1로 설정하는 것이 중요한 부분입니다. 이렇게 초기화하면 아무 것도 클릭되지 않은 상태를 명확히 표시할 수 있어, 클릭된 좌표를 추적하는 로직이 정확하게 작동하게 됩니다.

이유:
clickedX[0] = -1와 clickedY[0] = -1로 초기화하면, 첫 번째 타일이 아직 클릭되지 않았다는 상태가 확실하게 정의됩니다. 그러므로 클릭된 좌표와 비교할 때 0, 0 좌표가 아닌 -1, -1로 초기화되어 있어 중복 클릭을 방지하고, 첫 번째 클릭이 정상적으로 작동하게 됩니다.
clickedX[1]와 clickedY[1] 역시 -1로 초기화함으로써 두 번째 클릭이 처음 상태에서부터 시작할 수 있도록 보장됩니다.
결과적으로:
clickedX와 clickedY 배열을 { -1, -1 }로 초기화하여, 첫 번째 클릭을 올바르게 추적할 수 있게 되며, 프로그램이 원하는 대로 작동하게 됩니다.


----------------------------------------------------------------6. 같은 이미지 맞출 시 클릭 안되게

case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
{
    // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
    int x = LOWORD(lParam);
    int y = HIWORD(lParam);

    // 클릭된 칸의 인덱스를 계산
    int px = x / TILE_SIZE; // 클릭된 칸의 x 좌표 (0부터 시작)
    int py = y / TILE_SIZE; // 클릭된 칸의 y 좌표 (0부터 시작)

    // 이미 클릭된 칸인지 확인
    if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
        // 이미 클릭된 칸이라면 처리하지 않고 리턴
        return 0;
    }

    // 이미 해당 칸이 revealed 상태라면, 즉 이미지가 이미 맞춰졌다면 클릭을 무시
    int index = py * BOARD_SIZE + px;
    if (revealed[index]) {
        return 0;  // 이미 맞춰졌다면 클릭하지 않음
    }


    // 클릭 횟수에 따라 처리
    if (clickCount < 2) {
        clickedX[clickCount] = px;
        clickedY[clickCount] = py;
        clickCount++;
    }
    else {

        // 두 이미지를 비교해서 동일한지 확인
        int firstIndex = clickedY[0] * BOARD_SIZE + clickedX[0];
        int secondIndex = clickedY[1] * BOARD_SIZE + clickedX[1];

        // 이미지가 동일한 경우 점수 추가 및 이미지를 숨기기
        if (imageIndices[firstIndex] == imageIndices[secondIndex]) {
            revealed[firstIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
            revealed[secondIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
        }
        else {
            // 이미지가 다르면 잠시 대기 후 숨기기
            revealed[firstIndex] = false;
            revealed[secondIndex] = false;
        }

        // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
        clickedX[0] = px;
        clickedY[0] = py;
        clickedX[1] = -1;  // 두 번째 이미지는 사라짐
        clickedY[1] = -1;
        clickCount = 1; // 다시 첫 번째 클릭 상태로
    }

    InvalidateRect(hWnd, NULL, TRUE); // 화면 다시 그리기
}
break;


bool revealed[BOARD_SIZE * BOARD_SIZE] = { false };  // revealed 배열 선언 (각 칸의 이미지가 맞춰졌는지 여부 추적)



--> 설명

1.-------------------------------

if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
    // 이미 클릭된 칸이라면 처리하지 않고 리턴
    return 0;
}
clickedX와 clickedY 배열은 현재 클릭된 타일의 좌표를 저장하고 있습니다. (clickCount에 따라 최대 2개의 좌표가 저장됨)
clickedX[0], clickedY[0]는 첫 번째 클릭, clickedX[1], clickedY[1]는 두 번째 클릭 좌표를 저장합니다.
만약 사용자가 이미 클릭한 타일을 다시 클릭했을 경우, 해당 타일을 다시 처리하지 않도록 return 0으로 함수를 종료시킵니다. 이로써 같은 타일을 중복해서 클릭하는 것을 방지합니다.

2.---------------------------

이미 해당 칸이 revealed 상태라면 클릭을 무시

int index = py * BOARD_SIZE + px;
if (revealed[index]) {
    return 0;  // 이미 맞춰졌다면 클릭하지 않음
}
revealed[] 배열은 각 타일의 이미지가 맞춰졌는지 여부를 추적하는 배열입니다.
클릭된 타일이 이미 맞춰져서 숨겨진 상태라면(revealed[index] == true), 해당 타일을 클릭하더라도 아무런 동작을 하지 않도록 합니다.
index는 클릭된 타일의 인덱스입니다. index = py * BOARD_SIZE + px는 2D 좌표 (px, py)를 1D 배열 인덱스로 변환합니다. 이 방식은 2D 배열을 1D 배열로 관리할 때 자주 사용됩니다.


3.-----------------------------------

두 이미지를 비교하여 동일한지 확인

else {
    // 두 이미지를 비교해서 동일한지 확인
    int firstIndex = clickedY[0] * BOARD_SIZE + clickedX[0];
    int secondIndex = clickedY[1] * BOARD_SIZE + clickedX[1];

    // 이미지가 동일한 경우 점수 추가 및 이미지를 숨기기
    if (imageIndices[firstIndex] == imageIndices[secondIndex]) {
        revealed[firstIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
        revealed[secondIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
    }
    else {
        // 이미지가 다르면 잠시 대기 후 숨기기
        revealed[firstIndex] = false;
        revealed[secondIndex] = false;
    }

    // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
    clickedX[0] = px;
    clickedY[0] = py;
    clickedX[1] = -1;  // 두 번째 이미지는 사라짐
    clickedY[1] = -1;
    clickCount = 1; // 다시 첫 번째 클릭 상태로
}

--> 설명 : 

두 번째 클릭 후 이미지 비교:

두 번째 클릭이 이루어진 후, 첫 번째 클릭과 두 번째 클릭을 비교하여 이미지가 같은지 확인합니다.
firstIndex와 secondIndex는 각각 첫 번째 클릭과 두 번째 클릭의 타일 인덱스입니다.
imageIndices[firstIndex] == imageIndices[secondIndex]가 참이면 두 이미지가 동일하므로, 해당 타일을 숨기지 않고 revealed[firstIndex]와 revealed[secondIndex]를 true로 설정하여 더 이상 보이지 않게 만듭니다.
만약 두 이미지가 다르면, 이미지를 다시 숨기기 위해 revealed[firstIndex]와 revealed[secondIndex]를 false로 설정합니다.
이렇게 하면 사용자가 두 이미지를 비교하여 맞추면 이미지를 숨기고, 틀리면 다시 숨기는 로직이 처리됩니다.

--> 또 설명 : 

3번째 클릭 상태 초기화:

clickCount가 2일 때, 이미 두 번째 클릭을 했으므로, 3번째 클릭으로 넘어갈 준비를 합니다.
첫 번째 클릭의 좌표는 clickedX[0], clickedY[0]에 저장하고, 두 번째 클릭의 좌표는 clickedX[1]과 clickedY[1]을 초기화하여 다시 첫 번째 클릭 상태로 돌아가게 됩니다.
clickCount를 1로 초기화하여 다시 첫 번째 클릭 상태로 전환합니다.

--------------------------------------------7. 이미지 맞출 때 색 변경

 // 이미지가 맞춰졌을 때 검정색으로 그리기
 int index = i * BOARD_SIZE + j;
 if (revealed[index]) {
     // 검정색으로 해당 칸을 덮어쓰기
     HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));  // 검정색 브러시
     HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrush);
     // 칸을 덮어쓰는 사각형을 그린다.
     Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);

     SelectObject(hdc, hOldBrush);  // 이전 브러시로 복원
     DeleteObject(hBrush);  // 사용한 브러시 삭제
 }
 else
 {
     // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
     for (int index = 0; index < clickCount; index++) {
         if (clickedX[index] == j && clickedY[index] == i) {
             //int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
             int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
             HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
             SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

             // 비트맵을 각 칸에 맞게 복사
             BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
         }
     }
 }

--> 설명

이미지 맞춘 칸 검정색 처리:

revealed[index]가 true일 경우, 해당 칸을 검정색으로 덮어쓰는 작업이 진행됩니다.
CreateSolidBrush(RGB(0, 0, 0))는 검정색 브러시를 생성하고, Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE)는 그 칸을 덮는 사각형을 그립니다.
이 부분은 이미지가 맞춰져서 더 이상 표시되지 않도록 하는 로직입니다.
이미지 보이도록 처리:

클릭된 타일에 대해서만 이미지를 표시하는 작업입니다.
clickedX와 clickedY 배열을 통해 클릭된 좌표를 추적하고, 해당 좌표에 맞는 이미지를 BitBlt를 사용하여 그리게 됩니다.

--------------------------------------------- 8. 점수 추가해서 점수 80점 맞출시 게임종료

   // 점수 텍스트 표시
   wchar_t scoreText[50];
   swprintf_s(scoreText, 50, L"점수: %d", score);  // 점수를 표시하는 문자열 생성
   TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));

--> 설명

wchar_t: C++에서 문자열을 저장할 때 사용되는 데이터 타입입니다. wchar_t는 16비트 혹은 32비트 크기의 문자 형식으로, 유니코드 문자를 저장할 수 있습니다. 여기서는 한글 등의 다국어 문자와 유니코드 문자를 다루기 위해 사용됩니다.
scoreText[50]: scoreText는 최대 50개의 문자를 저장할 수 있는 배열입니다. 점수를 출력할 문자열을 저장할 공간입니다.


2.

swprintf_s: 이 함수는 안전한 문자열 형식을 지원하는 함수로, scoreText 배열에 점수를 포함한 문자열을 작성하는 역할을 합니다.
scoreText: 생성한 문자열을 저장할 변수입니다.
50: scoreText 배열의 최대 크기입니다. 배열이 초과되지 않도록 안전하게 문자열을 생성합니다.
L"점수: %d": 출력할 문자열 형식입니다. L은 이 문자열이 유니코드 문자열임을 나타냅니다. "점수: %d"는 score 값을 정수 형식으로 출력할 수 있도록 설계된 포맷입니다.
%d: 정수형으로 score 값을 출력하라는 포맷입니다.
score: 출력할 실제 값입니다. 점수를 저장하고 있는 변수입니다.

3.

TextOut: 이 함수는 지정된 좌표에 문자열을 그리는 함수입니다.
hdc: HDC (Handle to Device Context)라는 윈도우에서 그래픽 작업을 할 때 사용하는 장치 컨텍스트입니다. 이를 통해 화면에 텍스트나 그래픽을 그릴 수 있습니다.
BOARD_SIZE * TILE_SIZE + 20: 텍스트가 출력될 x 좌표입니다. BOARD_SIZE는 게임 보드의 크기, TILE_SIZE는 각 타일의 크기를 나타내는데, 이를 곱한 값은 보드의 전체 너비입니다. 여기에 20을 더함으로써, 보드 오른쪽에 일정한 여백을 두고 점수 텍스트가 출력되게 합니다.
10: y 좌표입니다. 화면의 세로 위치를 지정합니다. 10은 화면의 위쪽에서 10픽셀 아래에 텍스트를 출력한다는 의미입니다.
scoreText: 그려질 문자열입니다. 이전 swprintf_s에서 생성한 "점수: 10"과 같은 문자열을 전달합니다.
wcslen(scoreText): 문자열의 길이를 구하는 함수입니다. scoreText의 길이를 구어서 TextOut 함수에 전달합니다. TextOut 함수는 주어진 길이만큼 문자를 화면에 출력합니다.


-------------------------9. 문제점(게임 종료가 안됨 마지막 남은 이미지에서 점수 추가 로직이 안됨

--> 이미지 다 맞춰지면 종료되는 로직(그런데 종료시간이 즉각안됨)

#define BOARD_SIZE 4 //보드의 크기 (4x4)
#define TILE_SIZE 128  // 각 칸의 크기 (128x128 픽셀)


HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열

int clickedX[2] = { -1,-1 };
int clickedY[2] = { -1,-1 };  // 클릭된 좌표 저장 (최대 2개)
int clickCount = 0;  // 클릭 횟수 추적

int imageIndices[BOARD_SIZE * BOARD_SIZE];  // 이미지 인덱스를 저장할 배열
bool imagesLoaded = false;  // 이미지를 한 번만 로드하도록 하기 위한 플래그

bool revealed[BOARD_SIZE * BOARD_SIZE] = { false };  // revealed 배열 선언 (각 칸의 이미지가 맞춰졌는지 여부 추적)

// 점수 변수
int score = 0;


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        if (!imagesLoaded) {
            // 과일 이미지 8개를 로드
            FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
            FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
            FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
            FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
            FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
            FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
            FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
            FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


            // 이미지 인덱스를 초기화
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                imageIndices[i] = i % 8;  // 8개의 이미지로 순환
            }

            // 랜덤으로 이미지 인덱스 섞기
            srand((unsigned int)time(NULL));  // 랜덤 시드 설정
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                int randomIndex = rand() % (BOARD_SIZE * BOARD_SIZE); // 랜덤 인덱스
                // 이미지 인덱스를 서로 교환
                int temp = imageIndices[i];
                imageIndices[i] = imageIndices[randomIndex];
                imageIndices[randomIndex] = temp;
            }

            imagesLoaded = true;  // 이미지를 로드했으므로 플래그 설정
        }



         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * TILE_SIZE; //시작 x좌표 0
                int y = i * TILE_SIZE; //시작 y좌표 0

                // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
                // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
                HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

                // 각 칸을 사각형으로 그리기 (구분선 추가)
                MoveToEx(hdc, x, y, NULL);
                LineTo(hdc, x + TILE_SIZE, y);
                LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
                LineTo(hdc, x, y + TILE_SIZE);
                LineTo(hdc, x, y);

                // 펜 복원
                SelectObject(hdc, hOldPen);
                DeleteObject(hPen); // 사용한 펜 삭제

                // 이미지가 맞춰졌을 때 검정색으로 그리기
                int index = i * BOARD_SIZE + j;
                if (revealed[index]) {
                    // 검정색으로 해당 칸을 덮어쓰기
                    HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));  // 검정색 브러시
                    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrush);
                    // 칸을 덮어쓰는 사각형을 그린다.
                    Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);

                    SelectObject(hdc, hOldBrush);  // 이전 브러시로 복원
                    DeleteObject(hBrush);  // 사용한 브러시 삭제
                }
                else
                {
                    // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
                    for (int index = 0; index < clickCount; index++) {
                        if (clickedX[index] == j && clickedY[index] == i) {
                            //int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                            int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
                            HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                            SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                            // 비트맵을 각 칸에 맞게 복사
                            BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
                        }
                    }
                }
            }
        }

        // 점수 텍스트 표시
        //wchar_t scoreText[50];
        //swprintf_s(scoreText, 50, L"점수: %d", score);  // 점수를 표시하는 문자열 생성
        //TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));


        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;
    case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
    {
        // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);

        // 클릭된 칸의 인덱스를 계산
        int px = x / TILE_SIZE; // 클릭된 칸의 x 좌표 (0부터 시작)
        int py = y / TILE_SIZE; // 클릭된 칸의 y 좌표 (0부터 시작)

        // 이미 클릭된 칸인지 확인
        if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
            // 이미 클릭된 칸이라면 처리하지 않고 리턴
            return 0;
        }

        // 이미 해당 칸이 revealed 상태라면, 즉 이미지가 이미 맞춰졌다면 클릭을 무시
        int index = py * BOARD_SIZE + px;
        if (revealed[index]) {
            return 0;  // 이미 맞춰졌다면 클릭하지 않음
        }


        // 클릭 횟수에 따라 처리
        if (clickCount < 2) {
            clickedX[clickCount] = px;
            clickedY[clickCount] = py;
            clickCount++;

        }
        else {

            // 두 이미지를 비교해서 동일한지 확인
            int firstIndex = clickedY[0] * BOARD_SIZE + clickedX[0];
            int secondIndex = clickedY[1] * BOARD_SIZE + clickedX[1];

            // 이미지가 동일한 경우 점수 추가 및 이미지를 숨기기
            if (imageIndices[firstIndex] == imageIndices[secondIndex]) {

                score += 10;  // 동일한 이미지를 클릭하면 점수 추가

                /*if (score == 80)
                {
                    InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신 요청
                    UpdateWindow(hWnd);  // 즉시 갱신

                    MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
                    PostQuitMessage(0);  // 프로그램 종료
                } */

                revealed[firstIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
                revealed[secondIndex] = true;  // 해당 이미지는 더 이상 보이지 않음


            }
            else {
                // 이미지가 다르면 잠시 대기 후 숨기기
                revealed[firstIndex] = false;
                revealed[secondIndex] = false;

            }

            // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
            clickedX[0] = px;
            clickedY[0] = py;
            clickedX[1] = -1;  // 두 번째 이미지는 사라짐
            clickedY[1] = -1;
            clickCount = 1; // 다시 첫 번째 클릭 상태로

        }

        // 모든 이미지가 맞춰졌는지 확인
       bool allRevealed = true;
        for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
            if (!revealed[i]) {
                allRevealed = false;
                break;
            }
        }

        // 모든 이미지가 맞춰졌다면 게임 종료
        if (allRevealed) {
            MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
            PostQuitMessage(0);  // 프로그램 종료
        }

        // 두 이미지가 맞았을 경우 즉시 화면 갱신
        InvalidateRect(hWnd, NULL, TRUE); // 화면 갱신
    }
    break;


--> 껏다 키면 좀 빨라지는 듯함


코드 추가 설명

-->>

revealed 배열:

각 칸의 상태를 나타내는 불리언 배열입니다.
true: 해당 칸의 이미지가 맞춰졌음.
false: 해당 칸의 이미지가 아직 맞춰지지 않음.
루프 동작:

게임판의 모든 칸(4x4라면 16칸)을 순차적으로 확인합니다.
배열 revealed를 통해 모든 칸이 맞춰졌는지 확인합니다.
하나라도 false인 칸이 발견되면 allRevealed을 false로 바꾸고 루프를 중단합니다.

2. 게임 종료 조건 확인
cpp
코드 복사
if (allRevealed) {
    MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
    PostQuitMessage(0);  // 프로그램 종료
}
allRevealed이 true일 경우:

이는 모든 이미지가 맞춰졌음을 의미합니다.
이 시점에서 게임이 종료됩니다.
동작:

MessageBox:
화면에 팝업 메시지를 띄워 "게임 클리어"를 알립니다.
메시지는 L"게임 클리어"(표시할 텍스트)와 L"게임 종료"(창 제목)으로 구성됩니다.
MB_OK는 "확인" 버튼을 가진 단순한 메시지 박스 유형입니다.
PostQuitMessage(0):
Windows 메시지 큐에 WM_QUIT 메시지를 보냅니다.
이 메시지가 도달하면 애플리케이션은 종료됩니다.

좀 뜸을 들여서 실행해보기 컴터 자원 


---------------------------10. 격차 두기

#define GAP 10;
 int x = j * (TILE_SIZE + GAP); // 간격을 포함한 x 위치 계산 //시작 x좌표 0
 int y = i * (TILE_SIZE + GAP); // 간격을 포함한 y 위치 계산 //시작 y좌표 0


----------------------------11. 타이머 추가

#define BOARD_SIZE 4 //보드의 크기 (4x4)
#define TILE_SIZE 128  // 각 칸의 크기 (128x128 픽셀)


HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열

int clickedX[2] = { -1,-1 };
int clickedY[2] = { -1,-1 };  // 클릭된 좌표 저장 (최대 2개)
int clickCount = 0;  // 클릭 횟수 추적

int imageIndices[BOARD_SIZE * BOARD_SIZE];  // 이미지 인덱스를 저장할 배열
bool imagesLoaded = false;  // 이미지를 한 번만 로드하도록 하기 위한 플래그

bool revealed[BOARD_SIZE * BOARD_SIZE] = { false };  // revealed 배열 선언 (각 칸의 이미지가 맞춰졌는지 여부 추적)

// 점수 변수
int score = 0;
#define GAP 10  // 타일 간의 간격 (예: 10픽셀)


int timeLeft = 30;  // 타이머 시간 30초로 설정

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
    {
        SetTimer(hWnd, 1, 1000, NULL);  // 1초 간격으로 타이머 설정
    }
    break;
    case WM_TIMER:
    {
        if (timeLeft > 0) {
            timeLeft--;  // 1초씩 줄어들기
            InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신
        }
        else {
            // 타이머가 0에 도달하면 게임 종료
            KillTimer(hWnd, 1);  // 타이머 종료
            MessageBox(hWnd, L"시간 초과! 게임이 종료되었습니다.", L"게임 종료", MB_OK);
            PostQuitMessage(0);  // 프로그램 종료
        }
    }
    break;
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        if (!imagesLoaded) {
            // 과일 이미지 8개를 로드
            FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
            FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
            FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
            FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
            FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
            FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
            FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
            FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


            // 이미지 인덱스를 초기화
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                imageIndices[i] = i % 8;  // 8개의 이미지로 순환
            }

            // 랜덤으로 이미지 인덱스 섞기
            srand((unsigned int)time(NULL));  // 랜덤 시드 설정
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                int randomIndex = rand() % (BOARD_SIZE * BOARD_SIZE); // 랜덤 인덱스
                // 이미지 인덱스를 서로 교환
                int temp = imageIndices[i];
                imageIndices[i] = imageIndices[randomIndex];
                imageIndices[randomIndex] = temp;
            }

            imagesLoaded = true;  // 이미지를 로드했으므로 플래그 설정
        }



         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * (TILE_SIZE + GAP); // 간격을 포함한 x 위치 계산 //시작 x좌표 0
                int y = i * (TILE_SIZE + GAP); // 간격을 포함한 y 위치 계산 //시작 y좌표 0


                // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
                // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
                HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

                // 각 칸을 사각형으로 그리기 (구분선 추가)
                MoveToEx(hdc, x, y, NULL);
                LineTo(hdc, x + TILE_SIZE, y);
                LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
                LineTo(hdc, x, y + TILE_SIZE);
                LineTo(hdc, x, y);

                // 펜 복원
                SelectObject(hdc, hOldPen);
                DeleteObject(hPen); // 사용한 펜 삭제

                // 이미지가 맞춰졌을 때 검정색으로 그리기
                int index = i * BOARD_SIZE + j;
                if (revealed[index]) {
                    // 검정색으로 해당 칸을 덮어쓰기
                    HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));  // 검정색 브러시
                    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrush);
                    // 칸을 덮어쓰는 사각형을 그린다.
                    Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);

                    SelectObject(hdc, hOldBrush);  // 이전 브러시로 복원
                    DeleteObject(hBrush);  // 사용한 브러시 삭제
                }
                else
                {
                    // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
                    for (int index = 0; index < clickCount; index++) {
                        if (clickedX[index] == j && clickedY[index] == i) {
                            //int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                            int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
                            HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                            SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                            // 비트맵을 각 칸에 맞게 복사
                            BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
                        }
                    }
                }
            }
        }

        // 점수 텍스트 표시
        //wchar_t scoreText[50];
        //swprintf_s(scoreText, 50, L"점수: %d", score);  // 점수를 표시하는 문자열 생성
        //TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));

        //타이머 표시
        wchar_t timerText[100];
        swprintf_s(timerText, 100, L"남은 시간: %d초",timeLeft);  // 점수와 시간 표시
        TextOut(hdc, BOARD_SIZE * TILE_SIZE + 50, 10, timerText, wcslen(timerText));

        // 점수 및 타이머 텍스트 표시
       /* wchar_t scoreText[100];
        swprintf_s(scoreText, 100, L"점수: %d  남은 시간: %d초", score, timeLeft);  // 점수와 시간 표시
        TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));*/



        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;
    case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
    {
        // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);

        // 클릭된 칸의 인덱스를 계산
        int px = x / TILE_SIZE; // 클릭된 칸의 x 좌표 (0부터 시작)
        int py = y / TILE_SIZE; // 클릭된 칸의 y 좌표 (0부터 시작)

        // 이미 클릭된 칸인지 확인
        if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
            // 이미 클릭된 칸이라면 처리하지 않고 리턴
            return 0;
        }

        // 이미 해당 칸이 revealed 상태라면, 즉 이미지가 이미 맞춰졌다면 클릭을 무시
        int index = py * BOARD_SIZE + px;
        if (revealed[index]) {
            return 0;  // 이미 맞춰졌다면 클릭하지 않음
        }


        // 클릭 횟수에 따라 처리
        if (clickCount < 2) {
            clickedX[clickCount] = px;
            clickedY[clickCount] = py;
            clickCount++;

        }
        else {

            // 두 이미지를 비교해서 동일한지 확인
            int firstIndex = clickedY[0] * BOARD_SIZE + clickedX[0];
            int secondIndex = clickedY[1] * BOARD_SIZE + clickedX[1];

            // 이미지가 동일한 경우 점수 추가 및 이미지를 숨기기
            if (imageIndices[firstIndex] == imageIndices[secondIndex]) {

                score += 10;  // 동일한 이미지를 클릭하면 점수 추가

                /*if (score == 80)
                {
                    InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신 요청
                    UpdateWindow(hWnd);  // 즉시 갱신

                    MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
                    PostQuitMessage(0);  // 프로그램 종료
                } */

                revealed[firstIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
                revealed[secondIndex] = true;  // 해당 이미지는 더 이상 보이지 않음


            }
            else {
                // 이미지가 다르면 잠시 대기 후 숨기기
                revealed[firstIndex] = false;
                revealed[secondIndex] = false;

            }

            // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
            clickedX[0] = px;
            clickedY[0] = py;
            clickedX[1] = -1;  // 두 번째 이미지는 사라짐
            clickedY[1] = -1;
            clickCount = 1; // 다시 첫 번째 클릭 상태로

        }

        // 모든 이미지가 맞춰졌는지 확인
       bool allRevealed = true;
        for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
            if (!revealed[i]) {
                allRevealed = false;
                break;
            }
        }

        // 모든 이미지가 맞춰졌다면 게임 종료
        if (allRevealed) {
            MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
            PostQuitMessage(0);  // 프로그램 종료
        }

        // 두 이미지가 맞았을 경우 즉시 화면 갱신
        InvalidateRect(hWnd, NULL, TRUE); // 화면 갱신
    }
    break;

코드 작성완료



--게임설명


시간안에 모든 이미지를 맞춰야한다.


---------------------코드 마무리 게임 끝나면 초 멈춤, 

#define BOARD_SIZE 4 //보드의 크기 (4x4)
#define TILE_SIZE 128  // 각 칸의 크기 (128x128 픽셀)


HBITMAP FruitImages[8]; // 과일 이미지를 저장할 배열

int clickedX[2] = { -1,-1 };
int clickedY[2] = { -1,-1 };  // 클릭된 좌표 저장 (최대 2개)
int clickCount = 0;  // 클릭 횟수 추적

int imageIndices[BOARD_SIZE * BOARD_SIZE];  // 이미지 인덱스를 저장할 배열
bool imagesLoaded = false;  // 이미지를 한 번만 로드하도록 하기 위한 플래그

bool revealed[BOARD_SIZE * BOARD_SIZE] = { false };  // revealed 배열 선언 (각 칸의 이미지가 맞춰졌는지 여부 추적)

// 점수 변수
int score = 0;
#define GAP 10  // 타일 간의 간격 (예: 10픽셀)


int timeLeft = 30;  // 타이머 시간 30초로 설정

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
    {
        SetTimer(hWnd, 1, 1000, NULL);  // 1초 간격으로 타이머 설정
    }
    break;
    case WM_TIMER:
    {
        // 게임 클리어가 되었는지 확인
         bool allRevealed = true;
        for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
            if (!revealed[i]) {
                allRevealed = false;
                break;
            }
        }

        if (!allRevealed) {
            // 타이머가 0보다 클 때만 타이머를 갱신
            if (timeLeft > 0) {
                timeLeft--;  // 1초씩 줄어들기
                InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신
            }
            else {
                // 타이머가 0에 도달하면 게임 종료
                KillTimer(hWnd, 1);  // 타이머 종료
                MessageBox(hWnd, L"시간 초과! 게임이 종료되었습니다.", L"게임 종료", MB_OK);
                PostQuitMessage(0);  // 프로그램 종료
            }
        }
        else {
            // 게임이 클리어되었으면 타이머를 멈추기
            KillTimer(hWnd, 1);  // 타이머 종료
        }

        InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신
    }
    break;
    case WM_PAINT:
    {


        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        HDC MemDC = CreateCompatibleDC(hdc); // 화면과 호환되는 메모리 DC 생성

       
        if (!imagesLoaded) {
            // 과일 이미지 8개를 로드
            FruitImages[0] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP1));  // 첫 번째 과일 이미지
            FruitImages[1] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP2));   // 두 번째 과일 이미지
            FruitImages[2] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP3));  // 세 번째 과일 이미지
            FruitImages[3] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP4));   // 네 번째 과일 이미지
            FruitImages[4] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP5)); // 다섯 번째 과일 이미지
            FruitImages[5] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP6));   // 여섯 번째 과일 이미지
            FruitImages[6] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP7)); // 일곱 번째 과일 이미지
            FruitImages[7] = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_BITMAP8)); // 여덟 번째 과일 이미지


            // 이미지 인덱스를 초기화
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                imageIndices[i] = i % 8;  // 8개의 이미지로 순환
            }

            // 랜덤으로 이미지 인덱스 섞기
            srand((unsigned int)time(NULL));  // 랜덤 시드 설정
            for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
                int randomIndex = rand() % (BOARD_SIZE * BOARD_SIZE); // 랜덤 인덱스
                // 이미지 인덱스를 서로 교환
                int temp = imageIndices[i];
                imageIndices[i] = imageIndices[randomIndex];
                imageIndices[randomIndex] = temp;
            }

            imagesLoaded = true;  // 이미지를 로드했으므로 플래그 설정
        }



         // 4x4 판 그리기
        for (int i = 0; i < BOARD_SIZE; i++) {
            for (int j = 0; j < BOARD_SIZE; j++) {
                // 각 칸의 위치 계산
                int x = j * (TILE_SIZE + GAP); // 간격을 포함한 x 위치 계산 //시작 x좌표 0
                int y = i * (TILE_SIZE + GAP); // 간격을 포함한 y 위치 계산 //시작 y좌표 0


                // 각 칸에 이미지를 그리기 전에 경계를 그리기 위해 선 그리기
                // 선택적으로 테두리를 두껍게 그리기 위해 굵은 펜 사용
                HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 0)); // 두꺼운 검은색 선
                HPEN hOldPen = (HPEN)SelectObject(hdc, hPen); // 기존 펜을 저장하고 새 펜을 선택

                // 각 칸을 사각형으로 그리기 (구분선 추가)
                MoveToEx(hdc, x, y, NULL);
                LineTo(hdc, x + TILE_SIZE, y);
                LineTo(hdc, x + TILE_SIZE, y + TILE_SIZE);
                LineTo(hdc, x, y + TILE_SIZE);
                LineTo(hdc, x, y);

                // 펜 복원
                SelectObject(hdc, hOldPen);
                DeleteObject(hPen); // 사용한 펜 삭제

                // 이미지가 맞춰졌을 때 검정색으로 그리기
                int index = i * BOARD_SIZE + j;
                if (revealed[index]) {
                    // 검정색으로 해당 칸을 덮어쓰기
                    HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 0));  // 검정색 브러시
                    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrush);
                    // 칸을 덮어쓰는 사각형을 그린다.
                    Rectangle(hdc, x, y, x + TILE_SIZE, y + TILE_SIZE);

                    SelectObject(hdc, hOldBrush);  // 이전 브러시로 복원
                    DeleteObject(hBrush);  // 사용한 브러시 삭제
                }
                else
                {
                    // 클릭된 좌표에 해당하는 칸에 이미지를 보이도록 처리
                    for (int index = 0; index < clickCount; index++) {
                        if (clickedX[index] == j && clickedY[index] == i) {
                            //int imageIndex = (i * BOARD_SIZE + j) % 8; // 이미지는 8개만 있으므로 8개 이미지 순환
                            int imageIndex = imageIndices[i * BOARD_SIZE + j]; // 랜덤으로 배치된 이미지 인덱스
                            HBITMAP currentImage = FruitImages[imageIndex]; // 현재 칸에 맞는 이미지 선택
                            SelectObject(MemDC, currentImage); // 메모리 DC에 이미지 선택

                            // 비트맵을 각 칸에 맞게 복사
                            BitBlt(hdc, x, y, TILE_SIZE, TILE_SIZE, MemDC, 0, 0, SRCCOPY);
                        }
                    }
                }
            }
        }

        // 점수 텍스트 표시
        //wchar_t scoreText[50];
        //swprintf_s(scoreText, 50, L"점수: %d", score);  // 점수를 표시하는 문자열 생성
        //TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));

        //타이머 표시
        wchar_t timerText[100];
        swprintf_s(timerText, 100, L"남은 시간: %d초",timeLeft);  // 점수와 시간 표시
        TextOut(hdc, BOARD_SIZE * TILE_SIZE + 50, 10, timerText, wcslen(timerText));

        // 점수 및 타이머 텍스트 표시
       /* wchar_t scoreText[100];
        swprintf_s(scoreText, 100, L"점수: %d  남은 시간: %d초", score, timeLeft);  // 점수와 시간 표시
        TextOut(hdc, BOARD_SIZE * TILE_SIZE + 20, 10, scoreText, wcslen(scoreText));*/



        // 자원 해제
        DeleteDC(MemDC); // 메모리 DC 해제

        EndPaint(hWnd, &ps);
    }
    break;
    case WM_LBUTTONDOWN:  // 마우스 왼쪽 버튼 클릭 이벤트
    {
        // 클릭된 좌표 계산 (클릭된 화면 좌표를 받아서 해당 칸의 좌표로 변환)
        int x = LOWORD(lParam);
        int y = HIWORD(lParam);

        // 클릭된 칸의 인덱스를 계산
        int px = x / TILE_SIZE; // 클릭된 칸의 x 좌표 (0부터 시작)
        int py = y / TILE_SIZE; // 클릭된 칸의 y 좌표 (0부터 시작)

        // 이미 클릭된 칸인지 확인
        if ((clickedX[0] == px && clickedY[0] == py) || (clickedX[1] == px && clickedY[1] == py)) {
            // 이미 클릭된 칸이라면 처리하지 않고 리턴
            return 0;
        }

        // 이미 해당 칸이 revealed 상태라면, 즉 이미지가 이미 맞춰졌다면 클릭을 무시
        int index = py * BOARD_SIZE + px;
        if (revealed[index]) {
            return 0;  // 이미 맞춰졌다면 클릭하지 않음
        }


        // 클릭 횟수에 따라 처리
        if (clickCount < 2) {
            clickedX[clickCount] = px;
            clickedY[clickCount] = py;
            clickCount++;

        }
        else {

            // 두 이미지를 비교해서 동일한지 확인
            int firstIndex = clickedY[0] * BOARD_SIZE + clickedX[0];
            int secondIndex = clickedY[1] * BOARD_SIZE + clickedX[1];

            // 이미지가 동일한 경우 점수 추가 및 이미지를 숨기기
            if (imageIndices[firstIndex] == imageIndices[secondIndex]) {

                score += 10;  // 동일한 이미지를 클릭하면 점수 추가

                /*if (score == 80)
                {
                    InvalidateRect(hWnd, NULL, TRUE);  // 화면 갱신 요청
                    UpdateWindow(hWnd);  // 즉시 갱신

                    MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
                    PostQuitMessage(0);  // 프로그램 종료
                } */

                revealed[firstIndex] = true;  // 해당 이미지는 더 이상 보이지 않음
                revealed[secondIndex] = true;  // 해당 이미지는 더 이상 보이지 않음


            }
            else {
                // 이미지가 다르면 잠시 대기 후 숨기기
                revealed[firstIndex] = false;
                revealed[secondIndex] = false;

            }

            // 3번째 클릭은 첫 번째 상태로 돌아가도록 초기화
            clickedX[0] = px;
            clickedY[0] = py;
            clickedX[1] = -1;  // 두 번째 이미지는 사라짐
            clickedY[1] = -1;
            clickCount = 1; // 다시 첫 번째 클릭 상태로

        }

        // 모든 이미지가 맞춰졌는지 확인
       bool allRevealed = true;
        for (int i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
            if (!revealed[i]) {
                allRevealed = false;
                break;
            }
        }

        // 모든 이미지가 맞춰졌다면 게임 종료
        if (allRevealed) {
            MessageBox(hWnd, L"게임 클리어", L"게임 종료", MB_OK);
            PostQuitMessage(0);  // 프로그램 종료
        }

        // 두 이미지가 맞았을 경우 즉시 화면 갱신
        InvalidateRect(hWnd, NULL, TRUE); // 화면 갱신
    }
    break;






